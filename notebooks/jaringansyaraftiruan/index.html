<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>GoFrendi&#39;s Articles  | Jaringan Syaraf Tiruan</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.40.1" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    

    <meta property="og:title" content="Jaringan Syaraf Tiruan" />
<meta property="og:description" content="Mitos Ada banyak mitos yang beredar tentang Jaringan Syaraf Tiruan (JST). Misalnya:
 JST mampu membuat sistem yang secerdas manusia. JST memberikan akurasi yang lebih tinggi daripada pemrograman konvensional. JST dan Kecerdasan Buatan (AI) akan mengambil alih dunia. JST meningkatkan akurasi sistem. JST itu cepat.  Mitos-mitos tersebut sebenarnya cukup menyesatkan. Di satu sisi, hal ini membuat banyak orang menjadi khawatir akan perkembangan AI. Sementara di sisi lain, ada juga mereka yang berharap terlalu banyak pada AI." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://gofrendiasgard.github.io/notebooks/jaringansyaraftiruan/" />



<meta property="article:published_time" content="2019-07-31T07:48:41&#43;07:00"/>

<meta property="article:modified_time" content="2019-07-31T07:48:41&#43;07:00"/>











<meta itemprop="name" content="Jaringan Syaraf Tiruan">
<meta itemprop="description" content="Mitos Ada banyak mitos yang beredar tentang Jaringan Syaraf Tiruan (JST). Misalnya:
 JST mampu membuat sistem yang secerdas manusia. JST memberikan akurasi yang lebih tinggi daripada pemrograman konvensional. JST dan Kecerdasan Buatan (AI) akan mengambil alih dunia. JST meningkatkan akurasi sistem. JST itu cepat.  Mitos-mitos tersebut sebenarnya cukup menyesatkan. Di satu sisi, hal ini membuat banyak orang menjadi khawatir akan perkembangan AI. Sementara di sisi lain, ada juga mereka yang berharap terlalu banyak pada AI.">


<meta itemprop="datePublished" content="2019-07-31T07:48:41&#43;07:00" />
<meta itemprop="dateModified" content="2019-07-31T07:48:41&#43;07:00" />
<meta itemprop="wordCount" content="3025">



<meta itemprop="keywords" content="Macine Learning," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Jaringan Syaraf Tiruan"/>
<meta name="twitter:description" content="Mitos Ada banyak mitos yang beredar tentang Jaringan Syaraf Tiruan (JST). Misalnya:
 JST mampu membuat sistem yang secerdas manusia. JST memberikan akurasi yang lebih tinggi daripada pemrograman konvensional. JST dan Kecerdasan Buatan (AI) akan mengambil alih dunia. JST meningkatkan akurasi sistem. JST itu cepat.  Mitos-mitos tersebut sebenarnya cukup menyesatkan. Di satu sisi, hal ini membuat banyak orang menjadi khawatir akan perkembangan AI. Sementara di sisi lain, ada juga mereka yang berharap terlalu banyak pada AI."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://gofrendiasgard.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      GoFrendi&#39;s Articles
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="Abouts page">
              Abouts
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/notebooks/" title="Notebooks page">
              Notebooks
            </a>
          </li>
          
        </ul>
      
      


<a href="https://facebook.com/gofrendi" target="_blank" class="link-transition facebook link dib z-999 pt3 pt0-l mr1" title="Facebook link" rel="noopener" aria-label="follow on Facebook——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>


<a href="https://twitter.com/goFrendiAsgard" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>









    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        NOTEBOOKS
      </p>
      <h1 class="f1 athelas mb1">Jaringan Syaraf Tiruan</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2019-07-31T07:48:41&#43;07:00">July 31, 2019</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h1 id="mitos">Mitos</h1>

<p>Ada banyak mitos yang beredar tentang Jaringan Syaraf Tiruan (JST). Misalnya:</p>

<ul>
<li>JST mampu membuat sistem yang secerdas manusia.</li>
<li>JST memberikan akurasi yang lebih tinggi daripada pemrograman konvensional.</li>
<li>JST dan Kecerdasan Buatan (AI) akan mengambil alih dunia.</li>
<li>JST meningkatkan akurasi sistem.</li>
<li>JST itu cepat.</li>
</ul>

<p>Mitos-mitos tersebut sebenarnya cukup menyesatkan. Di satu sisi, hal ini membuat banyak orang menjadi khawatir akan perkembangan AI. Sementara di sisi lain, ada juga mereka yang berharap terlalu banyak pada AI.</p>

<p>Dalam artikel ini, saya ingin menunjukkan bagaimana sebenarnya cara kerja JST secara teknis. Harapannya. Setelah teman-teman membaca artikel ini, teman-teman tidak lagi merasa takut atau berharap terlalu banyak pada AI dan JST.</p>

<h1 id="jaringan-syaraf-tiruan-vs-jaringan-syaraf-asli">Jaringan Syaraf Tiruan VS Jaringan Syaraf Asli</h1>

<p>Banyak penulis yang mengawali pembahasannya dengan menganalogikan JST dan jaringan syaraf manusia. Walaupun tidak salah, namun pembahasan tersebut kerap mengarahkan pembaca pada harapan yang berlebihan.</p>

<p>Misalnya begini: &ldquo;Oh, karena saya bisa jatuh cinta, maka JST pun juga akan bisa jatuh cinta&rdquo;.</p>

<p>Tentu saja tidak benar. Kalau mau jujur, sampai saat ini pun kita tidak terlalu tahu bagaimana otak bekerja. Kita bahkan belum bisa memformulasikan &ldquo;apa itu kesadaran&rdquo;. Dan JST (sekalipun terinspirasi oleh jaringan syaraf asli), sebenarnya memiliki kapabilitas yang jauh di bawah manusia.</p>

<p>Sebelum kita lanjutkan pada pembahasan yang lebih detail, mari kita mulai dengan permasalahan sederhana.</p>

<h1 id="permasalahan-berat-badan-ideal">Permasalahan Berat Badan Ideal</h1>

<p>Anton, Budi, dan Cecep masing-masing mengaku memiliki berat badan ideal. Dari penampakan mereka, tampaknya ketiga orang tersebut tidak berbohong.</p>

<p>Anton memiliki tinggi badan 165 cm dan berat badan 65 kg, sedangkan Budi memiliki tinggi badan 170 cm dan berat badan 70 kg.</p>

<p>Permasalahannya, Si Cecep lupa berapa berat badannya, dan dia hanya ingat tinggi badannya 163 cm. Tanpa memakai timbangan, bisakah kita mengira-ngira berat badan Cecep?</p>

<p>Nah, permasalahan ini sebenarnya bisa diselesaikan dengan aljabar sederhana, selama kita mampu memodelkan persamaannya. Untungnya dalam kasus ini, permodelannya cukup sederhana. (Konon, entah benar atau tidak, permodelan berat badan ideal untuk orang yang tingginya di atas 150 cm itu sesuai dengan fungsi linear).</p>

<p>Misalnya kita anggap berat badan adalah <code>y</code>, sedangkan tinggi badan adalah <code>x</code>. Maka berat badan ideal bisa ditentukan dengan rumus <code>y = mx + c</code> di mana <code>m</code> dan <code>c</code> adalah angka-angka dengan nilai tertentu.</p>

<p>Oke, tampaknya alam semesta tidak terlalu berpihak pada kita. Karena untuk menentuka berat badan Cecep (<code>y-cecep</code>), kita tidak bisa hanya mengandalkan tinggi nya saja (<code>x-cecep</code>). Sebaliknya, kita harus tahu juga nilai <code>m</code> dan <code>c</code> yang ideal.</p>

<p>Untungnya, kita punya Anton dan Budi. Karena rumus berat badan ideal itu seharusnya sama untuk setiap orang, maka nilai <code>m</code> dan <code>c</code> untuk Anton dan Buid, harusnya berlaku pula untuk Cecep.</p>

<p>Mari kita coba:</p>

<pre><code>y = mx + c, di mana y adalah berat badan, sedangkan x adalah tinggi badan.
Maka
   Untuk Anton: 65 = m * 165 + c
   Untuk Budi : 70 = m * 170 + c
</code></pre>

<p>Mari kita fokus ke Anton dulu:</p>

<pre><code>65 = (m * 165) + c
c = 65 - (m * 165)
</code></pre>

<p>Hmm&hellip; tidak terlalu membantu, tapi setidaknya kita tahu bagaimana hubungan antara <code>c</code> dan <code>m</code>. Sekarang, mari kita fokus ke Budi:</p>

<pre><code>70 = m * 170 + c
</code></pre>

<p>Karena <code>c = 65 - (m * 165)</code>, maka kita bisa tulis ulang persamaan berat badan Budi dengan mengganti nilai <code>c</code> sehingga menjadi seperti ini:</p>

<pre><code>70 = (m * 170) + 65 - (m * 165)
70 - 65 = (m * 170) - (m * 165)
5 = m * (170 * 165)
5 = m * 5
m = 5/5
m = 1
</code></pre>

<p>Oke, sekarang kita tahu nilai <code>m</code>. Mari kita lanjutkan dengan mencari nilai <code>c</code>. Kita bisa kembali lagi fokus ke salah satu, Anton atau Budi. Lagi-lagi karena nilai <code>m</code> dan <code>c</code> untuk kedua persamaan tersebut sama persis, maka tidak masalah memilih Anton atau Budi. Untuk kali ini kita pilih Anton.</p>

<pre><code>65 = m * 165 + c
65 = 1 * 165 + c
65 = 165 + c
c = 65 - 165
c = -100
</code></pre>

<p>Nah, akhirnya kita menemukan nilai <code>m</code> dan <code>c</code>. Dari sini kita bisa simpulkan bahwa rumus berat badan ideal untuk orang yang tingginya di atas 150 cm adalah <code>y = (1 * x) - 100</code>, di mana <code>y</code> adalah berat badan, dan <code>x</code> adalah tinggi badan.</p>

<p>Akhirnya, dengan rumus berat badan ideal yang sudah kita temukan tadi, kita bisa menemukan berat badan Cecep. Karena tinggi badan Cecep adalah 163 cm, maka:</p>

<pre><code>y = (1 * 163) - 100
y = 63
</code></pre>

<p>Jadi berat badan Cecep adalah 63 kg.</p>

<p>Teknik yang baru kita lakukan tadi disebut teknik <code>subtitusi</code>. Teknik ini cukup berguna untuk melakukan berbagai macam konversi linear saat kita lupa &ldquo;rumus resmi&rdquo; nya. Rumus konversi Celcius-Fahrenhait-Reamur, atau tingkat-kemurnian-emas (dalam persen) ke karat, dan sebagainya. Saat berhadapan dengan kasus-kasus seperti itu, kita hanya butuh kertas dan pensil. Tidak butuh AI :)</p>

<p>Sedikit fakta menarik, ternyata perhitungan kita barusan, sesuai dengan artikel ini: <a href="https://lifestyle.kompas.com/read/2017/08/21/081619320/begini-cara-menghitung-berat-badan-ideal-anda">https://lifestyle.kompas.com/read/2017/08/21/081619320/begini-cara-menghitung-berat-badan-ideal-anda</a>. Tentu saja, karena saya sudah mencocokkan angka-angkanya terlebih dahulu :)</p>

<h1 id="lebih-jauh-dengan-permasalahan-berat-badan-ideal">Lebih Jauh dengan Permasalahan Berat Badan Ideal</h1>

<p>Berat badan ideal adalah masalah kita semua. Sedikit saja kita kurang bergerak dan terlalu banyak makan, maka kita akan jadi terlalu gemuk. Sebaliknya, jika kita makan terlalu sedikit, maka kita akan jadi terlalu kurus. Dalam hal ini memiliki berat badan ideal itu bisa dianalogikan seperti berjalan di atas seutas tali tipis, sedikit terlalu ke kiri, atau sedikit terlalu ke kanan, maka kita akan jatuh ke dalam lembah <code>obesitas</code> (berat badan lebih dari seharusnya) atau <code>mal-nutrisi</code> (berat badan kurang dari seharusnya).</p>

<p>Nah, menariknya, analogi yang saya tulis barusan tadi ternyata persis sama dengan permodelan matematika yang ada:</p>

<pre><code>y = 1 * m - 100
</code></pre>

<p><img src="http://gofrendiasgard.github.io/images/algebra-line.PNG" alt="" /></p>

<p>Dengan cara yang sama kita dapat memodelkan <code>obesitas</code> dengan pertidaksamaan:</p>

<pre><code>y &gt; 1 * m - 100
</code></pre>

<p><img src="http://gofrendiasgard.github.io/images/algebra-greater-than-line.PNG" alt="" /></p>

<p>Atau <code>mal-nutrisi</code> dengan pertidaksamaan:</p>

<pre><code>y &lt; 1 * m - 100
</code></pre>

<p><img src="http://gofrendiasgard.github.io/images/algebra-less-than-line.PNG" alt="" /></p>

<p>Fakta-fakta menarik ini akan membantu kita untuk memahami bahasan selanjutnya.</p>

<h1 id="regresi-vs-klasifikasi">Regresi VS Klasifikasi</h1>

<p>Kembali ke kasus Anton, Budi, dan Cecep. Ketiga orang tersebut memiliki data sebagai berikut:</p>

<pre><code>Target: y

Nama  | Tinggi (x) | Berat (y)
------------------------------
Anton | 165        | 65
Budi  | 170        | 70
Cecep | 163        | 63
</code></pre>

<p>Kita cukup beruntung karena jika digambarkan, posisi mereka ada dalam satu garis lurus <code>y = 1 * x + c</code>. Di sini kita lihat, bahwa nilai target yang kita cari (dalam hal ini berat), bisa sangat bervariasi. Secara matematis, bahkan kita bisa katakan bahwa kemungkinan nilai berat ini tak terbatas. Bisa jadi ada orang yang beratnya 65,1 kg, atau 65,100013 kg, dan seterusnya.</p>

<p>Nah untuk kasus di mana nilai target yang kita cari memiliki kemungkinan yang sangat banyak, kita sebut permasalahannya sebagai <code>regresi</code>. Seperti yang sudah kita duga, <code>regresi</code> bisa diselesaikan dengna cara mencari garis/bidang model (dalam kasus kita, model nya adalah garis <code>y = 1 * x - 100</code>. Selanjutnya data baru akan kita cocokkan dengan model tersebut sehingga nilai target bisa ditemukan.</p>

<p>Sekarang bayangkan, bagaimana jika kita punya kasus yang berbeda</p>

<pre><code>Target: z

Nama   | Tinggi (x) | Berat (y) | Kategori (z)
-----------------------------------------------
Anton  | 165        | 65        | Ideal
Budi   | 170        | 70        | Ideal
Cecep  | 163        | 63        | Ideal
Didit  | 163        | 40        | Mal-nutrisi
Emil   | 170        | 50        | Mal-nutrisi
Frank  | 150        | 40        | Mal-nutrisi
Ganot  | 170        | 100       | Obesitas
Herman | 165        | 80        | Obesitas
Ical   | 180        | 120       | Obesitas
</code></pre>

<p>Kali ini target kita adalah kategori. Berbeda dengan kasus <code>regresi</code> di contoh sebelumnya, sekarang kita hanya punya tiga kemungkinan target, yakni <code>ideal</code>, <code>mal-nutrisi</code>, dan <code>obesitas</code>. Permasalahan ini disebut permasalahan <code>klasifikasi</code>.</p>

<p>Jika pada <code>regresi</code> kita mencocokkan data terhadap model, maka pada <code>klasifikasi</code>, kita menggunakan model untuk memisahkan data (Mirip seperti kasus <code>pertidaksamaan linear</code> pada contoh sebelumnya).</p>

<p>Walaupun sepintas permasalahan regresi dan klasifikasi tampak berbeda, namun langkah awalnya sama: Menentukan model.</p>

<p>Dengan sedikit abstraksi, kita bisa mengubah permasalahan klasifikasi ke ranah regresi. Kita ambil kembali contoh di atas. Kali ini dengan atribut <code>rasio</code>:</p>

<pre><code>Target: z

Nama   | Tinggi (x) | Berat (y) | Rasio (w=y/(x-100)) | Kategori (z)
--------------------------------------------------------------------
Anton  | 165        | 65        | 1                   | Ideal
Budi   | 170        | 70        | 1                   | Ideal
Cecep  | 163        | 63        | 1                   | Ideal
Didit  | 163        | 40        | 0.63                | Mal-nutrisi
Emil   | 170        | 50        | 0.71                | Mal-nutrisi
Frank  | 150        | 40        | 0.80                | Mal-nutrisi
Ganot  | 170        | 100       | 1.42                | Obesitas
Herman | 165        | 80        | 1.23                | Obesitas
Ical   | 180        | 120       | 1.5                 | Obesitas
</code></pre>

<p>Pertama-tama kita melakukan <code>regresi</code> untuk mencari nilai rasio, kemudian kita melakukan klasifikasi berdasarkan rasio tersebut. Misalnya, jika rasio kurang dari satu berarti mal-nutrisi, jika lebih dari satu, berarti obesitas, dan jika sama dengan satu berarti ideal.</p>

<p>Abstraksi tersebut bukanlah satu-satunya cara yang mungkin. Masih ada banyak cara lain yang tidak kita bahas di sini.</p>

<h1 id="kita-dan-alam-semesta-yang-tidak-ideal">Kita dan Alam Semesta yang Tidak Ideal</h1>

<p>Regresi adalah satu teknik yang sangat berguna. Dalam dunia yang ideal, kita bisa saja memprediksi harga saham dan tanah ataupun menebak perasaan &lsquo;si dia&rsquo; dengan menggunakan permodelan yang tepat.</p>

<p>Sayangnya, <strong>alam semesta tidak ideal</strong>, dan <strong>kita tidak maha tahu</strong>. Ketidak-idealan alam semesta mungkin bisa digambarkan seperti berikut:</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Linear_regression.svg/1200px-Linear_regression.svg.png" alt="" /></p>

<p>Pada gambar di atas, kita bisa lihat bahwa dari sekian banyak titik yang ada,jarang sekali yang benar-benar berada dalam garis model. Banyak hal di dunia ini yang tidak bisa 100% ditebak. Lemparan dua mata dadu misalnya, tidak mungkin memunculkan angka 13 atau 0. Kemungkinan kecil memunculkan angka 1 atau 12, dan besar kemungkinan memunculkan angka 5,6, dan 7. Hanya sejauh itulah yang kita tahu.</p>

<p>Ada berbagai model statistik untuk menghitung peluang, tapi tidak ada yang 100% akurat. Maka dalam dunia yang tidak ideal ini, perlu sekali bagi kita untuk berkompromi dan men-toleransi banyak hal.</p>

<p>Salah satu cara untuk menerapkan <code>toleransi</code> pada matematika adalah dengan membuat <code>error function</code> atau <code>loss function</code>. Tujuan kita pun bergeser, bukan lagi menebak secara akurat, namun menebak dengan kesalahan seminimal mungkin. Salah satu <code>error function</code> yang paling primitif dan cukup sering dipakai adalah:</p>

<p>$$E=\sqrt{(Target-Output)^2}$$</p>

<p>Kalian mungkin bertanya-tanya, kenapa tidak sekedar <code>Target-Output</code> saja? Nah, <code>Target-Output</code> mungkin saja memberikan hasil negatif. Ini akan menimbulkan masalah saat kita mencoba menjumlahkan nilai <code>error</code> total.</p>

<pre><code>Target | Output | Target - Output | sqrt((Target-Output)^2) 
-----------------------------------------------------------
 8     | -8     |  16             | 16
-8     |  8     | -16             | 16
-----------------------------------------------------------
Total           |   0 (Loh???)    | 32 (Seharusnya begini)
</code></pre>

<p>Adanya <code>akar</code> dan <code>kuadrat</code> pada rumus <code>error function</code> dimaksudkan untuk menghindari masalah ini.</p>

<p>Dengan menentukan <code>error function</code> yang tepat, maka kita mampu <strong>mengukur kesalahan</strong> dan <strong>membuat model yang lebih toleran</strong>.</p>

<p>Tapi kita masih punya masalah kedua. Kita tidak maha tahu, dan tidak semua masalah bisa diselesaikan dengan persamaan linear.</p>

<p>Lalu apa yang harus kita lakukan?</p>

<p>Jawaban yang naif adalah &ldquo;mencoba satu-satu&rdquo;. Dalam beberapa kasus, kita bisa saja cukup beruntung dan menemukan model yang tepat.</p>

<p>Dalam keadaan normal, biasanya pola sebaran statistika akan mengikuti fungsi Gauss (<a href="https://en.wikipedia.org/wiki/Gaussian_function">https://en.wikipedia.org/wiki/Gaussian_function</a>). Tapi tentu saja, ini pertaruhan yang belum tentu berhasil.</p>

<p>Cara yang sedikit lebih baik, adalah dengan membuat kerangka model yang cukup general. Bisa diumpamakan seperti kita memakai swiss-army knife yang jika dilipat-lipat dengan konfigurasi yang benar, bisa memunculkan suatu alat yang berguna untuk menyelesaikan permasalahan kita.</p>

<p>Menurut saya, inilah definisi jaringan syaraf tiruan: Sebuah model matematis yang cukup general, mudah dikonfigurasi dan diotak-atik. Tapi cukup susah untuk dihitung secara manual. :)</p>

<h1 id="fondasi-jaringan-syaraf-tiruan-perceptron">Fondasi Jaringan Syaraf Tiruan: Perceptron</h1>

<p>Seperti yang biasa digambarkan di buku-buku atau artikel yang membahas tentang JST, struktur umum JST adalah sebagai berikut:</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/9/99/Neural_network_example.svg" alt="" /></p>

<p>Setiap lingkaran pada gambar di atas disebut <code>perceptron</code> atau <code>neuron</code>. Kita bisa menambahkan jumlah neuron dan menatanya sesuai kebutuhan.</p>

<p>Jika dibedah lebih detail, maka setiap lingkaran atau <code>perceptron</code> pada gambar sebelumnya bisa dijabarkan sebagai berikut:</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/31/Perceptron.svg" alt="" /></p>

<p>Saat perceptron-perceptron tersebut dirangkai, maka akan muncul model matematika yang lebih kompleks. Sebelum masuk ke sana, ada baiknya kita membedah dan memahami bagaimana <code>perceptron</code> bekerja.</p>

<h2 id="feed-forward">Feed Forward</h2>

<p>Mari kita lihat lagi persamaan yang ada pada sebuah perceptron:</p>

<p>$$o=f(\Sigma^n_{k=1}i_k.W_k)$$</p>

<p>Kita bisa memecah persamaan tersebut menjadi dua bagian, yakni</p>

<p>$$y=\Sigma^n_{k=1}i_k.W_k &hellip; (penjumlahan)$$</p>

<p>dan</p>

<p>$$o=f(y) &hellip; (aktivasi)$$</p>

<h3 id="bagian-penjumlahan">Bagian Penjumlahan</h3>

<p>Oke, mari kita fokus terlebih dahulu pada bagian pertama. Bagian ini sebenarnya adalah generalisasi dari persamaan linear yang sudah kita bahas pada kasus <code>berat badan ideal</code>. Jika dijabarkan lagi, kita akan memperoleh bentuk penjumlahan sebagai berikut:</p>

<p>$$y=\Sigma^n_{k=1}(i_k.W_k)$$</p>

<p>$$y=i_1.W_1 + i_2.W_2 + &hellip; + i_n.W_n$$</p>

<p>Ini mirip sekali dengan persamaan garis linear:</p>

<p>$$y=m.x + c$$</p>

<p>Bayangkan saja, sekarang untuk menetukan <code>y</code> (berat badan), kita tak lagi hanya bergantung <code>x</code> (tinggi badan), melainkan ada faktor-faktor lain seperti <code>x2</code> (ukuran sepatu), <code>x3</code> (cangkir kopi yang dihabiskan tiap hari), <code>x4</code> (Porsi nasi sekali makan) dan seterusnya. Maka kita akan menemukan persamaan seperti ini:</p>

<p>$$y=m_1.x_1 + m_2.x_2 + m_3.x_3 + m_4.x_4 + c$$</p>

<p>Persamaan tersebut sudah cukup mirip dengan persamaan <code>bagian penjumlahan</code> pada <code>perceptron</code>. Apalagi jika kita mengganti <code>m</code> dengan <code>W</code> dan <code>x</code> dengan <code>i</code>.</p>

<p>Supaya lebih mirip lagi, biasanya pada sebuah perceptron ditambahkan nilai <code>bias</code>. Beberapa referensi menggunakan simbol tersendiri untuk nilai <code>bias</code>. Tapi di tulisan ini, kita akan simbolkan bias dengan <code>m_5</code>.</p>

<p>$$y=m_1.x_1 + m_2.x_2 + m_3.x_3 + m_4.x_4 + m_5.x_5$$</p>

<p>dimana <code>x_5</code> selalu bernilai <code>1</code>.</p>

<p>Sekarang kita bisa yakin bahwa <code>bagian penjumlahan</code> pada sebuah <code>perceptron</code> tak lain adalah <strong>persamaan linear</strong>.</p>

<p>Kembali lagi ke kasus awal (dengan sedikit modifikasi):</p>

<pre><code>Kategori:
  0   : mal-nutrisi
  0.5 : ideal
  1   : obesitas

Nama  | Tinggi (i_1) | Porsi makan (i_2) | Kategori (t)
-------------------------------------------------------
Anton | 165          | 3                 | 0.5 (ideal)
</code></pre>

<p>Maka kita bisa menghitung nilai <code>y</code> dengan cara berikut:</p>

<p>$$y=\Sigma^n_{k=1}(i_k.W_k)$$</p>

<p>$$y=i_1.W_1 + i_2.W_2 + i_3.W_3$$</p>

<p>Nilai <code>w1</code>, <code>w2</code>, dan <code>w3</code> akan kita tentukan secara acak. Misalnya kita ambil <code>w1</code> = 0.3, <code>w2</code> = 0.2, dan <code>w3</code> = 0.1, maka:</p>

<pre><code>y = 165 * 0.3 + 3 * 0.2 + 0.1
</code></pre>

<h3 id="bagian-aktivasi">Bagian Aktivasi</h3>

<p>Usai melakukan penjumlahan, langkah selanjutnya adalah melakukan aktivasi. Jika pada bagian penjumlahan kita sudah menciptakan satu persamaan linear, maka fungsi aktivasi bertugas untuk menghadapi ketidak-linearan data. Pada dasarnya fungsi aktivasi bertujuan untuk memetakan output persamaan linear dari <code>bagian penjumlahan</code> menjadi tidak linear.</p>

<p>Ada beberapa fungsi aktivasi yang umum dipakai. Penjelasan lebih lanjut tentang fungsi aktivasi bisa dilihat pada artikel ini: <a href="https://towardsdatascience.com/activation-functions-neural-networks-1cbd9f8d91d6">https://towardsdatascience.com/activation-functions-neural-networks-1cbd9f8d91d6</a></p>

<p><img src="https://miro.medium.com/max/1005/1*p_hyqAtyI8pbt2kEl6siOQ.png" alt="" /></p>

<p>Dari sekian banyak fungsi aktivasi yang ada, tampaknya ada dua yang paling sering dipakai, yakni <code>sigmoid</code> ( atau <code>logistic</code>) dan <code>ReLu</code> (serta <code>Leaky ReLu</code>).</p>

<p>Jika kita yakin data kita pasti linear, maka ada baiknya kita tidak memakai jaringan syaraf tiruan. Lebih baik lakukan <code>linear regression</code> yang jauh lebih sederhana dan cepat. Atau kalau masih ingin memakai JST, gunakan fungsi aktivasi linear (yang pada dasarnya tidak melakukan apapun).</p>

<p>Untuk menghindari <code>vanishing gradient problem</code>, umumnya praktisi deep learning lebih menyukai <code>ReLu</code> atau <code>Leaky ReLu</code>. Kedua fungsi ini juga kerap dipilih karena perhitungannya yang sederhana.</p>

<p>Ok, kembali ke kasus awal. Semisal kita memilih fungsi <code>logistic</code>, maka kita harus melakukan ini:</p>

<pre><code>y = 165 * 0.3 + 3 * 0.2 + 0.1

o = f(y)
o = 1 / [1 + e^-(165 * 0.3 + 3 * 0.2 + 0.1)]
</code></pre>

<p><code>e</code> sendiri adalah bilangan euler yang nilainya mendekati <code>2.718</code> (<a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">https://en.wikipedia.org/wiki/E_(mathematical_constant)</a>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#ff79c6">import</span> math
<span style="color:#bd93f9">1</span><span style="color:#ff79c6">/</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">+</span> math<span style="color:#ff79c6">.</span>exp(<span style="color:#bd93f9">165</span> <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">0.3</span> <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">3</span> <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">0.2</span> <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0.1</span>))</code></pre></div>
<pre><code>1.5791268155225368e-22
</code></pre>

<h2 id="back-propagation">Back Propagation</h2>

<p>Jika diperhatikan, tentu saja hasil perhitungan feed-forward ini meleset jauh. Tapi jangan khawatir. JST punya mekanisme untuk memperbaiki nilai <code>W</code> sehingga nantinya nilai output yang dihasilkan akan mendekati target.</p>

<p>Untuk memperbaiki nilai <code>W</code>, maka kita butuh dua macam informasi:</p>

<ul>
<li>Seberapa besar nilai <code>W</code></li>
<li>Bagaimana kita harus mengubah nilai <code>W</code></li>
</ul>

<p>JST menjawab pertanyaan pertama dengan menyediakan satu parameter yang disebut <code>learning rate</code>.</p>

<p>Untuk pertanyaan kedua, jawabannya ternyata jauh lebih kompleks, karena kita membutuhkan perhitungan kalkulus. Sebelum kita melangkah lebih jauh, mari kita lihat, bagaimana kalkulus bisa membantu.</p>

<h3 id="kalkulus-dan-fungsi-turunan">Kalkulus dan Fungsi Turunan</h3>

<p>Konsep kalkulus pertama kali diperkenalkan oleh Newton untuk menghitung perubahan sesaat. Sebelum kita membicarakan tentang perubahan sesaat.</p>

<p>Semisal ada fungsi <code>f(x) = x^2</code>, maka untuk <code>x = {0 .. 4}</code>, kita bisa memperoleh data perubahan nilai <code>f(x)</code> sebagai berikut</p>

<pre><code>x_i | y_i = f(x_i)    | Delta = y_(i+1) - y_i
---------------------------------------------
0   | 0  = 0^2        | 1
1   | 1  = 1^2 = 0+1  | 3
2   | 4  = 2^2 = 1+3  | 5
3   | 9  = 3^2 = 4+5  | 7
4   | 16 = 4^2 = 9+7  | 9
</code></pre>

<p>Jika kita generalisasi, maka kita akan temukan bahwa</p>

<p>$$\Delta = \frac{f(x_i + h) - f(x_i)}{h}$$</p>

<p>Mari kita buktikan. Dalam kasus kita ini, karena <code>h = 1</code>, maka untuk <code>x = 2</code>, seharusnya kita akan ketemukan <code>Delta = 5</code></p>

<pre><code>Delta = [f(2+1) - f(2)] / 1
Delta = [f(3) - f(2)] / 1
Delta = (3^2 - 2^2) / 1
Delta = (9 - 4) / 1
Delta = 5
</code></pre>

<p>Terbukti.</p>

<p>Nah konsep perubahan sesaat sebenarnya mirip dengan konsep yang sudah kita jabarkan di atas. Hanya saja kali ini nilai <code>h</code> nya mendekati nol. Mengapa mendekati nol? Karena kita tidak mungkin menghitung perubahan nilai <code>f(x)</code> jika perubahan <code>x</code> nya sendiri adalan nol. Ibarat kita melihat foto sebuah mobil, dan disuruh mengira-ngira kecepatannya. Tidak mungkin bisa. Setidaknya kita butuh 2 foto. Foto mobil saat ini, dan foto beberapa mili-detik setelahnya. Kecepatan bisa ditentukan dengan cara menghitung perubahan posisi mobil dibagi dengan perubahan waktu pengambilan foto.</p>

<p><img src="https://1.bp.blogspot.com/-z0MS_ogXHSo/UZPXglI1TyI/AAAAAAAAKxQ/GJJkeY7Ho-I/s1600/Audi+Car+(7).jpg" alt="" /></p>

<p>Oleh sebab itu rumus untuk menghitung Delta perlu kita ubah, sehingga nilai <code>h</code> nya kecil sekali (mendekati nol). Kebetulan dalam matematika ada konsep <code>limit</code> (mendekati namun tak sampai :( ). Oleh karena itu, rumus menghitung delta bisa kita tulis sebagai berikut:</p>

<p>$$\Delta = Limit _{h -&gt; 0} \frac{f(x_i + h) - f(x_i)}{h}$$</p>

<p>Formula untuk menghitung Delta inilah yang kemudian kita kenal dengan <code>derivative</code> atau <code>fungsi turunan</code>. Singkatnya, fungsi turunan adalah fungsi untuk menghitung perubahan sesaat.</p>

<p>Mari kita lihat contoh perhitungan untuk mencari fungsi turunan dari <code>f(x) = x^2</code>:</p>

<p>$$f&rsquo;(x) = Limit _{h -&gt; 0} \frac{f(x + h) - f(x)}{h}$$
$$f&rsquo;(x) = Limit _{h -&gt; 0} \frac{(x + h)^2 - (x)^2}{h}$$
$$f&rsquo;(x) = Limit _{h -&gt; 0} \frac{(x + h).(x + h) - x^2}{h}$$
$$f&rsquo;(x) = Limit _{h -&gt; 0} \frac{x^2 + x_i.h + x.h + h^2 - x^2}{h}$$
$$f&rsquo;(x) = Limit _{h -&gt; 0} \frac{x^2 + 2.x_i.h + h^2 - x^2}{h}$$
$$f&rsquo;(x) = Limit _{h -&gt; 0} \frac{2.x.h + h^2}{h}$$
$$f&rsquo;(x) = Limit _{h -&gt; 0} \frac{h.(2.x+h)}{h}$$
$$f&rsquo;(x) = Limit _{h -&gt; 0} 2.x+h$$
$$f&rsquo;(x) = 2.x$$</p>

<p>Perhitungan di atas selaras dengan rumus turunan untuk fungsi pemangkatan:</p>

<p>$$f(x) = x^r, f&rsquo;(x) = r.x^{r-1}$$</p>

<p>Dalam prakteknya, Kita perlu mencari fungsi turunan terhadap setiap nilai <code>w</code> dari fungsi ini:</p>

<p>$$E = \frac{1}{2}.(t-f(\Sigma^n_{k=1}i_k.W_k))^2$$</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"></code></pre></div><ul class="pa0">
  
   <li class="list">
     <a href="/tags/macine-learning" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Macine Learning</a>
   </li>
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/notebooks/neuralnetwork/">Neural Network From Scratch</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://gofrendiasgard.github.io/" >
    &copy; 2019 GoFrendi&#39;s Articles
  </a>
    <div>


<a href="https://facebook.com/gofrendi" target="_blank" class="link-transition facebook link dib z-999 pt3 pt0-l mr1" title="Facebook link" rel="noopener" aria-label="follow on Facebook——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>


<a href="https://twitter.com/goFrendiAsgard" target="_blank" class="link-transition twitter link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel="noopener" aria-label="follow on Twitter——Opens in a new window">
  <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

<span class="new-window"><svg  height="8px"  style="enable-background:new 0 0 1000 1000;" version="1.1" viewBox="0 0 1000 1000" width="8px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" >
<path d="M598 128h298v298h-86v-152l-418 418-60-60 418-418h-152v-86zM810 810v-298h86v298c0 46-40 86-86 86h-596c-48 0-86-40-86-86v-596c0-46 38-86 86-86h298v86h-298v596h596z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>
</span></a>








</div>
  </div>
</footer>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript">
  
  const images = document.getElementsByTagName("img");
  for (const image of images) {
    const oldSrc = image.src;
    const correctedSrc = getCorrectedSrc(oldSrc);
    image.src = correctedSrc;
  }

  
  
  function getCorrectedSrc(oldSrc) {
    const regex = /(.*)\/([a-z0-9_\- ]*)\/([a-z0-9_\- ]*)_files\/(.*)/gmi;
    const matches = regex.exec(oldSrc);
    if (matches && matches[2] === matches[3]) {
      const prefix = matches[1];
      const title = matches[2];
      const sufix = matches[4];
      return [prefix, title+"_files", sufix].join("/");
    }
    return oldSrc;
  }
</script>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
